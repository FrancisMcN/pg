/*
 * (c) 2025 Francis McNamee
 * */
 
package ie.francis.pg;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class JavaPrinter implements Printer {

  private final Grammar grammar;
  private final StringBuilder sb;
  private int depth;

  public JavaPrinter(Grammar grammar) {
    this.grammar = grammar;
    this.sb = new StringBuilder();
    this.depth = 0;
  }

  public String print() {

    sb.append(String.format("/* Generated by pg v%s */\n\n", Version.VERSION_STRING));
    sb.append("class Parser {\n\n");
    depth++;
    sb.append(String.format("%sprivate final Scanner scanner;\n\n", StringUtil.indent(depth)));
    depth--;

    depth++;

    sb.append(String.format("%sParser(Scanner scanner) {\n", StringUtil.indent(depth)));
    depth++;
    sb.append(String.format("%sthis.scanner = scanner;\n", StringUtil.indent(depth)));
    depth--;
    sb.append(String.format("%s}\n", StringUtil.indent(depth)));
    sb.append("\n");

    sb.append(String.format("%spublic void parse() {\n", StringUtil.indent(depth)));
    depth++;
    sb.append(String.format("%s%s();\n", StringUtil.indent(depth), this.grammar.getStart()));
    depth--;
    sb.append(String.format("%s}\n", StringUtil.indent(depth)));
    sb.append("\n");

    for (NonTerminal nonTerminal : this.grammar.getRules().keySet()) {
      List<Rule> rules = this.grammar.getRules().get(nonTerminal);

      for (Rule rule : rules) {
        sb.append(
            String.format(
                "%s// %s -> %s\n", StringUtil.indent(depth), nonTerminal, joinTerms(rule.terms())));
      }

      sb.append(String.format("%sprivate void %s() {\n", StringUtil.indent(depth), nonTerminal));
      Map<Term, List<Set<Term>>> predictSets = this.grammar.getPredict();
      List<Set<Term>> sets = predictSets.get(nonTerminal);

      depth++;
      sb.append(StringUtil.indent(depth));
      for (int i = 0; i < sets.size(); i++) {
        List<Term> tokens = new ArrayList<>(sets.get(i));
        sb.append("if (");
        for (int j = 0; j < tokens.size(); j++) {
          sb.append(String.format("nextTokenIs(%s)", formatToken(tokens.get(j))));
          if (j < tokens.size() - 1) {
            sb.append(" || ");
          }
        }
        sb.append(") {\n");
        depth++;
        Rule rule = rules.get(i);
        for (Term term : rule.terms()) {
          if (term instanceof NonTerminal) {
            sb.append(String.format("%s%s();\n", StringUtil.indent(depth), term));
          } else {
            //                        sb.append(String.format("%s\n", formatToken(term)));
            sb.append(String.format("%sscanner.next();\n", StringUtil.indent(depth)));
          }
        }
        depth--;

        sb.append(String.format("%s}", StringUtil.indent(depth)));
        if (i < sets.size() - 1) {
          sb.append(" else ");
        }
      }
      // If a non-terminal is in EPS then don't throw syntax error
      // when reaching the end of the function
      sb.append(" else {\n");
      depth++;
      sb.append(
          String.format(
              "%sthrow new SyntaxErrorException(\"expected %s\");",
              StringUtil.indent(depth), printSyntaxError(sets)));
      depth--;
      sb.append(String.format("\n%s}\n", StringUtil.indent(depth)));
      depth--;

      sb.append(String.format("%s}\n\n", StringUtil.indent(depth)));
    }

    sb.append(
        String.format("%sprivate boolean nextTokenIs(Token token) {\n", StringUtil.indent(depth)));
    depth++;
    sb.append(
        String.format(
            "%sreturn scanner.peek().type() == token.type();\n", StringUtil.indent(depth)));
    depth--;
    sb.append(String.format("%s}\n", StringUtil.indent(depth)));
    sb.append("\n");

    sb.append(
        String.format("%sprivate boolean nextTokenIs(String token) {\n", StringUtil.indent(depth)));
    depth++;
    sb.append(
        String.format(
            "%sreturn scanner.peek().type() == Token.lookup(token);\n", StringUtil.indent(depth)));
    depth--;
    sb.append(String.format("%s}\n", StringUtil.indent(depth)));
    sb.append("\n");

    depth--;

    sb.append("}\n");

    return sb.toString();
  }

  private String joinTerms(List<Term> terms) {
    StringBuilder sb = new StringBuilder();
    for (Term term : terms) {
      sb.append(formatToken(term));
      sb.append(" ");
    }
    return sb.toString();
  }

  private String printSyntaxError(List<Set<Term>> sets) {
    StringBuilder sb = new StringBuilder();
    List<Term> tokens = new ArrayList<>();
    for (Set<Term> set : sets) {
      tokens.addAll(set);
    }
    for (int i = 0; i < tokens.size(); i++) {
      sb.append(tokens.get(i));
      if (i < tokens.size() - 2) {
        sb.append(", ");
      } else if (i == tokens.size() - 2) {
        sb.append(" or ");
      }
    }
    return sb.toString();
  }

  private String formatToken(Term token) {
    if (!token.toString().matches("[A-Za-z]+")) {
      return String.format("\"%s\"", token);
    }
    return token.toString();
  }
}
